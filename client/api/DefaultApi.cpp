/**
 * Sensor Data API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.20
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.3.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


#include "DefaultApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace io {
namespace swagger {
namespace client {
namespace api {

using namespace io::swagger::client::model;

DefaultApi::DefaultApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

DefaultApi::~DefaultApi()
{
}

pplx::task<void> DefaultApi::aggregationGet(utility::string_t streamid, utility::string_t start, utility::string_t end, bool si, bool ei, double limit, double aggperiod, utility::string_t count)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/aggregation");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->aggregationGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("streamid")] = ApiClient::parameterToString(streamid);
    }
    
    {
        queryParams[U("start")] = ApiClient::parameterToString(start);
    }
    
    {
        queryParams[U("end")] = ApiClient::parameterToString(end);
    }
    
    {
        queryParams[U("si")] = ApiClient::parameterToString(si);
    }
    
    {
        queryParams[U("ei")] = ApiClient::parameterToString(ei);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("aggperiod")] = ApiClient::parameterToString(aggperiod);
    }
    
    {
        queryParams[U("count")] = ApiClient::parameterToString(count);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->aggregationGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling aggregationGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling aggregationGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::collectionsCollectionidSharesGet(utility::string_t collectionid, utility::string_t id, double limit, double skip, bool expand, bool recursive, utility::string_t organisationid, utility::string_t groupid)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/{collectionid}/shares");
    boost::replace_all(path, U("{") U("collectionid") U("}"), ApiClient::parameterToString(collectionid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsCollectionidSharesGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("groupid")] = ApiClient::parameterToString(groupid);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsCollectionidSharesGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsCollectionidSharesGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsCollectionidSharesGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::collectionsCollectionidSharesIdDelete(utility::string_t collectionid, utility::string_t id)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/{collectionid}/shares/{id}");
    boost::replace_all(path, U("{") U("collectionid") U("}"), ApiClient::parameterToString(collectionid));
boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsCollectionidSharesIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsCollectionidSharesIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsCollectionidSharesIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsCollectionidSharesIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::collectionsCollectionidSharesIdGet(utility::string_t collectionid, utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/{collectionid}/shares/{id}");
    boost::replace_all(path, U("{") U("collectionid") U("}"), ApiClient::parameterToString(collectionid));
boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsCollectionidSharesIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsCollectionidSharesIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsCollectionidSharesIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsCollectionidSharesIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<CollectionCollection>> DefaultApi::collectionsCountGet(double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t streamids)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/count");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsCountGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("streamids")] = ApiClient::parameterToString(streamids);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsCountGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsCountGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsCountGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<CollectionCollection> result(new CollectionCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling collectionsCountGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<CollectionCollection>> DefaultApi::collectionsGet(double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t streamids)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("streamids")] = ApiClient::parameterToString(streamids);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<CollectionCollection> result(new CollectionCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling collectionsGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::collectionsIdDelete(utility::string_t id)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::collectionsIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::collectionsIdPut(utility::string_t id, std::shared_ptr<CollectionPut> body, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( U("application/json") );

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::collectionsPost(std::shared_ptr<CollectionPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->collectionsPost"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/collections");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->collectionsPost does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->collectionsPost does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling collectionsPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling collectionsPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<GroupCollection>> DefaultApi::groupsGet(utility::string_t id, utility::string_t organisationid, utility::string_t groupids, double limit, double skip, bool expand, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/groups");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->groupsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->groupsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling groupsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling groupsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<GroupCollection> result(new GroupCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling groupsGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::groupsIdDelete(utility::string_t id, bool cascade)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/groups/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->groupsIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("cascade")] = ApiClient::parameterToString(cascade);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->groupsIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling groupsIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling groupsIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::groupsIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/groups/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->groupsIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->groupsIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling groupsIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling groupsIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::groupsIdPut(utility::string_t id, std::shared_ptr<GroupPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->groupsIdPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/groups/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->groupsIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->groupsIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling groupsIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling groupsIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<Invitation>> DefaultApi::invitationsIdAcceptPost(utility::string_t id)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/invitations/{id}/accept");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->invitationsIdAcceptPost does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->invitationsIdAcceptPost does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling invitationsIdAcceptPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling invitationsIdAcceptPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Invitation> result(new Invitation());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling invitationsIdAcceptPost: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Invitation>> DefaultApi::invitationsIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/invitations/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->invitationsIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->invitationsIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling invitationsIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling invitationsIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Invitation> result(new Invitation());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling invitationsIdGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Invitation>> DefaultApi::invitationsPost(std::shared_ptr<InvitationPost> body)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/invitations");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/hal+json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->invitationsPost does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( U("application/json") );


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->invitationsPost does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling invitationsPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling invitationsPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Invitation> result(new Invitation());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling invitationsPost: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<LocationCollection>> DefaultApi::locationsCountGet(utility::string_t id, utility::string_t description, double limit, double skip, utility::string_t organisationid, utility::string_t groupids, bool expand, utility::string_t near, double radius)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/locations/count");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->locationsCountGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("description")] = ApiClient::parameterToString(description);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("near")] = ApiClient::parameterToString(near);
    }
    
    {
        queryParams[U("radius")] = ApiClient::parameterToString(radius);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->locationsCountGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling locationsCountGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling locationsCountGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<LocationCollection> result(new LocationCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling locationsCountGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<LocationCollection>> DefaultApi::locationsGet(utility::string_t id, utility::string_t description, double limit, double skip, utility::string_t organisationid, utility::string_t groupids, bool expand, utility::string_t near, double radius)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/locations");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->locationsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("description")] = ApiClient::parameterToString(description);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("near")] = ApiClient::parameterToString(near);
    }
    
    {
        queryParams[U("radius")] = ApiClient::parameterToString(radius);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->locationsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling locationsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling locationsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<LocationCollection> result(new LocationCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling locationsGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::locationsIdDelete(utility::string_t id, bool cascade)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/locations/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->locationsIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("cascade")] = ApiClient::parameterToString(cascade);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->locationsIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling locationsIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling locationsIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::locationsIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/locations/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->locationsIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->locationsIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling locationsIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling locationsIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::locationsIdPut(utility::string_t id, std::shared_ptr<LocationPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->locationsIdPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/locations/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->locationsIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->locationsIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling locationsIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling locationsIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::observationsDelete(utility::string_t streamid)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/observations");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->observationsDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("streamid")] = ApiClient::parameterToString(streamid);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->observationsDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling observationsDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling observationsDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::observationsGet(utility::string_t streamid, utility::string_t start, utility::string_t end, utility::string_t time, bool si, bool ei, utility::string_t bounds, utility::string_t media, double limit, utility::string_t sort)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/observations");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->observationsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("streamid")] = ApiClient::parameterToString(streamid);
    }
    
    {
        queryParams[U("start")] = ApiClient::parameterToString(start);
    }
    
    {
        queryParams[U("end")] = ApiClient::parameterToString(end);
    }
    
    {
        queryParams[U("time")] = ApiClient::parameterToString(time);
    }
    
    {
        queryParams[U("si")] = ApiClient::parameterToString(si);
    }
    
    {
        queryParams[U("ei")] = ApiClient::parameterToString(ei);
    }
    
    {
        queryParams[U("bounds")] = ApiClient::parameterToString(bounds);
    }
    
    {
        queryParams[U("media")] = ApiClient::parameterToString(media);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("sort")] = ApiClient::parameterToString(sort);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->observationsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling observationsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling observationsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::observationsPost(utility::string_t streamid, std::shared_ptr<ObservationsPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->observationsPost"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/observations");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->observationsPost does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("streamid")] = ApiClient::parameterToString(streamid);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->observationsPost does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling observationsPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling observationsPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<OrganisationCollection>> DefaultApi::organisationsGet()
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/organisations");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->organisationsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->organisationsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling organisationsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling organisationsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<OrganisationCollection> result(new OrganisationCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling organisationsGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Organisation>> DefaultApi::organisationsOrganisationidGet(utility::string_t organisationid)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/organisations/{organisationid}");
    boost::replace_all(path, U("{") U("organisationid") U("}"), ApiClient::parameterToString(organisationid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->organisationsOrganisationidGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->organisationsOrganisationidGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling organisationsOrganisationidGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling organisationsOrganisationidGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Organisation> result(new Organisation());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling organisationsOrganisationidGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Organisation>> DefaultApi::organisationsOrganisationidPut(utility::string_t organisationid, std::shared_ptr<OrganisationPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->organisationsOrganisationidPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/organisations/{organisationid}");
    boost::replace_all(path, U("{") U("organisationid") U("}"), ApiClient::parameterToString(organisationid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->organisationsOrganisationidPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->organisationsOrganisationidPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling organisationsOrganisationidPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling organisationsOrganisationidPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Organisation> result(new Organisation());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling organisationsOrganisationidPut: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<PlatformCollection>> DefaultApi::platformsGet(utility::string_t id, utility::string_t name, double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t streamids, utility::string_t deployments_locationid)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/platforms");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->platformsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("name")] = ApiClient::parameterToString(name);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("streamids")] = ApiClient::parameterToString(streamids);
    }
    
    {
        queryParams[U("deployments.locationid")] = ApiClient::parameterToString(deployments_locationid);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->platformsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling platformsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling platformsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<PlatformCollection> result(new PlatformCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling platformsGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::platformsIdDelete(utility::string_t id, bool cascade)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/platforms/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->platformsIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("cascade")] = ApiClient::parameterToString(cascade);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->platformsIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling platformsIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling platformsIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::platformsIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/platforms/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->platformsIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->platformsIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling platformsIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling platformsIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::platformsIdPut(utility::string_t id, std::shared_ptr<PlatformPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->platformsIdPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/platforms/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->platformsIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->platformsIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling platformsIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling platformsIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<SensingProcedureCollection>> DefaultApi::proceduresGet(double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t observedProperty)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/procedures");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->proceduresGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("observedProperty")] = ApiClient::parameterToString(observedProperty);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->proceduresGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling proceduresGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling proceduresGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<SensingProcedureCollection> result(new SensingProcedureCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling proceduresGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::proceduresIdDelete(utility::string_t id, bool cascade)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/procedures/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->proceduresIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("cascade")] = ApiClient::parameterToString(cascade);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->proceduresIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling proceduresIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling proceduresIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::proceduresIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/procedures/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->proceduresIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->proceduresIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling proceduresIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling proceduresIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::proceduresIdPut(utility::string_t id, std::shared_ptr<SensingProcedurePost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->proceduresIdPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/procedures/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->proceduresIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->proceduresIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling proceduresIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling proceduresIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<RoleCollection>> DefaultApi::rolesGet(bool expand, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/roles");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->rolesGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->rolesGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling rolesGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling rolesGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<RoleCollection> result(new RoleCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling rolesGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::rolesRoleidDelete(utility::string_t roleid)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/roles/{roleid}");
    boost::replace_all(path, U("{") U("roleid") U("}"), ApiClient::parameterToString(roleid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->rolesRoleidDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->rolesRoleidDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling rolesRoleidDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling rolesRoleidDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<Role>> DefaultApi::rolesRoleidGet(utility::string_t roleid, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/roles/{roleid}");
    boost::replace_all(path, U("{") U("roleid") U("}"), ApiClient::parameterToString(roleid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->rolesRoleidGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->rolesRoleidGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling rolesRoleidGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling rolesRoleidGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Role> result(new Role());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling rolesRoleidGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Role>> DefaultApi::rolesRoleidPut(utility::string_t roleid, std::shared_ptr<RolePost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->rolesRoleidPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/roles/{roleid}");
    boost::replace_all(path, U("{") U("roleid") U("}"), ApiClient::parameterToString(roleid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->rolesRoleidPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->rolesRoleidPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling rolesRoleidPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling rolesRoleidPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Role> result(new Role());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling rolesRoleidPut: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::rootGet()
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->rootGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->rootGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling rootGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling rootGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<ShareCollection>> DefaultApi::sharesCountGet(double limit, double skip, utility::string_t organisationid, utility::string_t groupid, utility::string_t collectionid, bool expand, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/shares/count");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->sharesCountGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("groupid")] = ApiClient::parameterToString(groupid);
    }
    
    {
        queryParams[U("collectionid")] = ApiClient::parameterToString(collectionid);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->sharesCountGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling sharesCountGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling sharesCountGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<ShareCollection> result(new ShareCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling sharesCountGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<ShareCollection>> DefaultApi::sharesGet(double limit, double skip, utility::string_t organisationid, utility::string_t groupid, utility::string_t collectionid, bool expand, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/shares");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->sharesGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("groupid")] = ApiClient::parameterToString(groupid);
    }
    
    {
        queryParams[U("collectionid")] = ApiClient::parameterToString(collectionid);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->sharesGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling sharesGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling sharesGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<ShareCollection> result(new ShareCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling sharesGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::sharesIdDelete(utility::string_t id)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/shares/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->sharesIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->sharesIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling sharesIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling sharesIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::sharesIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/shares/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->sharesIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->sharesIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling sharesIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling sharesIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::sharesIdPut(utility::string_t id, std::shared_ptr<SharePut> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->sharesIdPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/shares/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->sharesIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->sharesIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling sharesIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling sharesIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> DefaultApi::sharesPost(std::shared_ptr<SharePost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->sharesPost"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/shares");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->sharesPost does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->sharesPost does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling sharesPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling sharesPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<StreamCollectionCount>> DefaultApi::streamsCountGet(utility::string_t id, double limit, double skip, utility::string_t resulttype, bool expand, bool recursive, utility::string_t groupids, utility::string_t organisationid, utility::string_t locationid, utility::string_t near, double radius, utility::string_t streamMetadata_observedProperty, utility::string_t streamMetadata_unitOfMeasure, utility::string_t properties)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/streams/count");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->streamsCountGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("resulttype")] = ApiClient::parameterToString(resulttype);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("locationid")] = ApiClient::parameterToString(locationid);
    }
    
    {
        queryParams[U("near")] = ApiClient::parameterToString(near);
    }
    
    {
        queryParams[U("radius")] = ApiClient::parameterToString(radius);
    }
    
    {
        queryParams[U("streamMetadata.observedProperty")] = ApiClient::parameterToString(streamMetadata_observedProperty);
    }
    
    {
        queryParams[U("streamMetadata.unitOfMeasure")] = ApiClient::parameterToString(streamMetadata_unitOfMeasure);
    }
    
    {
        queryParams[U("properties")] = ApiClient::parameterToString(properties);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->streamsCountGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling streamsCountGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling streamsCountGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<StreamCollectionCount> result(new StreamCollectionCount());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling streamsCountGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<StreamCollection>> DefaultApi::streamsGet(utility::string_t id, double limit, double skip, utility::string_t resulttype, bool expand, bool recursive, utility::string_t groupids, utility::string_t organisationid, utility::string_t locationid, utility::string_t near, double radius, utility::string_t streamMetadata_observedProperty, utility::string_t streamMetadata_unitOfMeasure, utility::string_t properties)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/streams");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->streamsGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }
    
    {
        queryParams[U("limit")] = ApiClient::parameterToString(limit);
    }
    
    {
        queryParams[U("skip")] = ApiClient::parameterToString(skip);
    }
    
    {
        queryParams[U("resulttype")] = ApiClient::parameterToString(resulttype);
    }
    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("groupids")] = ApiClient::parameterToString(groupids);
    }
    
    {
        queryParams[U("organisationid")] = ApiClient::parameterToString(organisationid);
    }
    
    {
        queryParams[U("locationid")] = ApiClient::parameterToString(locationid);
    }
    
    {
        queryParams[U("near")] = ApiClient::parameterToString(near);
    }
    
    {
        queryParams[U("radius")] = ApiClient::parameterToString(radius);
    }
    
    {
        queryParams[U("streamMetadata.observedProperty")] = ApiClient::parameterToString(streamMetadata_observedProperty);
    }
    
    {
        queryParams[U("streamMetadata.unitOfMeasure")] = ApiClient::parameterToString(streamMetadata_unitOfMeasure);
    }
    
    {
        queryParams[U("properties")] = ApiClient::parameterToString(properties);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->streamsGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling streamsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling streamsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<StreamCollection> result(new StreamCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling streamsGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::streamsIdDelete(utility::string_t id)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/streams/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->streamsIdDelete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->streamsIdDelete does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling streamsIdDelete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling streamsIdDelete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<Stream>> DefaultApi::streamsIdGet(utility::string_t id, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/streams/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->streamsIdGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->streamsIdGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling streamsIdGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling streamsIdGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Stream> result(new Stream());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling streamsIdGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::streamsIdPut(utility::string_t id, std::shared_ptr<StreamPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->streamsIdPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/streams/{id}");
    boost::replace_all(path, U("{") U("id") U("}"), ApiClient::parameterToString(id));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->streamsIdPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->streamsIdPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling streamsIdPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling streamsIdPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<UserCollection>> DefaultApi::usersGet(bool expand, bool recursive, utility::string_t roleids)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/users");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->usersGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("expand")] = ApiClient::parameterToString(expand);
    }
    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }
    
    {
        queryParams[U("roleids")] = ApiClient::parameterToString(roleids);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->usersGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling usersGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling usersGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<UserCollection> result(new UserCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling usersGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<User>> DefaultApi::usersUseridGet(utility::string_t userid, bool recursive)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/users/{userid}");
    boost::replace_all(path, U("{") U("userid") U("}"), ApiClient::parameterToString(userid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->usersUseridGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("recursive")] = ApiClient::parameterToString(recursive);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->usersUseridGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling usersUseridGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling usersUseridGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<User> result(new User());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling usersUseridGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<User>> DefaultApi::usersUseridPut(utility::string_t userid, std::shared_ptr<UserPost> body)
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'body' when calling DefaultApi->usersUseridPut"));
    }


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/users/{userid}");
    boost::replace_all(path, U("{") U("userid") U("}"), ApiClient::parameterToString(userid));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->usersUseridPut does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;


    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("DefaultApi->usersUseridPut does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling usersUseridPut: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling usersUseridPut: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<User> result(new User());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling usersUseridPut: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<VocabularyCollection>> DefaultApi::vocabularyGet(utility::string_t query, utility::string_t type)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/vocabulary");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->vocabularyGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("query")] = ApiClient::parameterToString(query);
    }
    
    {
        queryParams[U("type")] = ApiClient::parameterToString(type);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->vocabularyGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling vocabularyGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling vocabularyGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<VocabularyCollection> result(new VocabularyCollection());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling vocabularyGet: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> DefaultApi::vocabularyProxyGet(utility::string_t id)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/vocabularyProxy");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->vocabularyProxyGet does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("id")] = ApiClient::parameterToString(id);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("DefaultApi->vocabularyProxyGet does not consume any supported media type"));
    }

    // authentication (headerkey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-apiKey"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-apiKey")] = apiKey;
        }
    }
    // authentication (kongheader) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-Consumer-Custom-ID"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-Consumer-Custom-ID")] = apiKey;
        }
    }
    // authentication (normal) required
    // Basic authentication is added automatically as part of the http_client_config
    // authentication (querykey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("apiKey"));
        if ( apiKey.size() > 0 )
        {
            queryParams[U("apiKey")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling vocabularyProxyGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling vocabularyProxyGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}

}
}
}
}

