/**
 * Sensor Data API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.20
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.3.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/*
 * DefaultApi.h
 *
 * 
 */

#ifndef DefaultApi_H_
#define DefaultApi_H_


#include "../ApiClient.h"

#include "ApiError.h"
#include "CollectionCollection.h"
#include "CollectionPost.h"
#include "CollectionPut.h"
#include "GroupCollection.h"
#include "GroupPost.h"
#include "Invitation.h"
#include "InvitationPost.h"
#include "LocationCollection.h"
#include "LocationPost.h"
#include "ObservationsPost.h"
#include "Organisation.h"
#include "OrganisationCollection.h"
#include "OrganisationPost.h"
#include "PlatformCollection.h"
#include "PlatformPost.h"
#include "Role.h"
#include "RoleCollection.h"
#include "RolePost.h"
#include "SensingProcedureCollection.h"
#include "SensingProcedurePost.h"
#include "ShareCollection.h"
#include "SharePost.h"
#include "SharePut.h"
#include "Stream.h"
#include "StreamCollection.h"
#include "StreamCollectionCount.h"
#include "StreamPost.h"
#include "User.h"
#include "UserCollection.h"
#include "UserPost.h"
#include "VocabularyCollection.h"
#include <cpprest/details/basic_types.h>

namespace io {
namespace swagger {
namespace client {
namespace api {

using namespace io::swagger::client::model;

class  DefaultApi
{
public:
    DefaultApi( std::shared_ptr<ApiClient> apiClient );
    virtual ~DefaultApi();
    /// <summary>
    /// Calculate an aggregated view of observations.
    /// </summary>
    /// <remarks>
    /// Calculate an aggregated view of observations. The aggregation is calculated on demand.
    /// </remarks>
    /// <param name="streamid">Stream identifier</param>/// <param name="start">Start date (url encoded iso8601 format) (optional)</param>/// <param name="end">End date (url encoded iso8601 format) (optional)</param>/// <param name="si">Is the start parameter treated as an inclusive boundary (optional)</param>/// <param name="ei">Is the end parameter treated as an inclusive boundary (optional)</param>/// <param name="limit">Limit the number of results. The limit is 1000 by default. (optional)</param>/// <param name="aggperiod">The number of milliseconds in each aggregation interval. (optional)</param>/// <param name="count">Include this parameter to return a count of the observations in a stream. (Note, a value is not required for this parameter.) (optional)</param>
    pplx::task<void> aggregationGet(utility::string_t streamid, utility::string_t start, utility::string_t end, bool si, bool ei, double limit, double aggperiod, utility::string_t count);
    /// <summary>
    /// Get shares for a collection
    /// </summary>
    /// <remarks>
    /// Get shares for a collection
    /// </remarks>
    /// <param name="collectionid"></param>/// <param name="id">Only return shares with this id or partial match using wildcards (*, ?).  \\n* matches zero or more characters.\\n* ? matches exactly one character.\\n\\nFor example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="limit">Maximum number of shares to return (optional)</param>/// <param name="skip">Skip this many results (optional)</param>/// <param name="expand">Return full details of matching shares (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="organisationid">Filter response by this organisation id (optional)</param>/// <param name="groupid">Filter response by a comma separated list of group ids (optional)</param>
    pplx::task<void> collectionsCollectionidSharesGet(utility::string_t collectionid, utility::string_t id, double limit, double skip, bool expand, bool recursive, utility::string_t organisationid, utility::string_t groupid);
    /// <summary>
    /// Delete a share from an existing collection.
    /// </summary>
    /// <remarks>
    /// Delete a share from an existing collection. The client must have an appropriate delete collection permission
    /// </remarks>
    /// <param name="collectionid"></param>/// <param name="id">The unique identifier for the share to be deleted from the collection</param>
    pplx::task<void> collectionsCollectionidSharesIdDelete(utility::string_t collectionid, utility::string_t id);
    /// <summary>
    /// Get details about a share resource
    /// </summary>
    /// <remarks>
    /// Get details about a specific share resource
    /// </remarks>
    /// <param name="collectionid"></param>/// <param name="id">The unique identifier for the share to be deleted from the collection</param>/// <param name="recursive">Return full details of embedded resources (optional, default to false)</param>
    pplx::task<void> collectionsCollectionidSharesIdGet(utility::string_t collectionid, utility::string_t id, bool recursive);
    /// <summary>
    /// Get a count of collections.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="limit">Maximum number of streams to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="expand">Return full details of platforms (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="groupids">filter response by a comma separated list of group ids (optional)</param>/// <param name="streamids">filter response by a comma separated list of stream ids (optional)</param>
    pplx::task<std::shared_ptr<CollectionCollection>> collectionsCountGet(double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t streamids);
    /// <summary>
    /// Get a list of collections.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="limit">Maximum number of streams to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="expand">Return full details of platforms (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="groupids">filter response by a comma separated list of group ids (optional)</param>/// <param name="streamids">filter response by a comma separated list of stream ids (optional)</param>
    pplx::task<std::shared_ptr<CollectionCollection>> collectionsGet(double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t streamids);
    /// <summary>
    /// Delete an existing Collection.
    /// </summary>
    /// <remarks>
    /// Delete an existing Collection. The client must have an appropriate delete Collection permission.
    /// </remarks>
    /// <param name="id"></param>
    pplx::task<void> collectionsIdDelete(utility::string_t id);
    /// <summary>
    /// Get details about a collection.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Collection id</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<void> collectionsIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Create or update a collection
    /// </summary>
    /// <remarks>
    /// Create or update a collection
    /// </remarks>
    /// <param name="id">The unique identifier for the target collection to create or update</param>/// <param name="body"> (optional)</param>/// <param name="recursive">Return full details of the created or updated collection (optional, default to false)</param>
    pplx::task<void> collectionsIdPut(utility::string_t id, std::shared_ptr<CollectionPut> body, bool recursive);
    /// <summary>
    /// Create a new collection.
    /// </summary>
    /// <remarks>
    /// Create a new collection. Do not provide the id property in the body. The server will generate a UUID.
    /// </remarks>
    /// <param name="body"></param>
    pplx::task<void> collectionsPost(std::shared_ptr<CollectionPost> body);
    /// <summary>
    /// Get a collection of groups.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Only return groups with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="groupids">filter response by a comma separated list of group ids (optional)</param>/// <param name="limit">Maximum number of streams to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="expand">Return full details of groups (optional)</param>/// <param name="recursive">Return full details of groups and linked objects (optional)</param>
    pplx::task<std::shared_ptr<GroupCollection>> groupsGet(utility::string_t id, utility::string_t organisationid, utility::string_t groupids, double limit, double skip, bool expand, bool recursive);
    /// <summary>
    /// Delete an existing group.
    /// </summary>
    /// <remarks>
    /// Delete an existing Group. The client must have an appropriate delete Group permission.
    /// </remarks>
    /// <param name="id"></param>/// <param name="cascade">Remove group even when not empty. (optional)</param>
    pplx::task<void> groupsIdDelete(utility::string_t id, bool cascade);
    /// <summary>
    /// Get details about a group.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Group id</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<void> groupsIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Create a new or update an existing group.
    /// </summary>
    /// <remarks>
    /// Create a new group. If a group with the posted &#39;id&#39; already exists then it will be overwritten.
    /// </remarks>
    /// <param name="id"></param>/// <param name="body"></param>
    pplx::task<void> groupsIdPut(utility::string_t id, std::shared_ptr<GroupPost> body);
    /// <summary>
    /// Accepts an invitation
    /// </summary>
    /// <remarks>
    /// Accepts an invitation.  Only the invited user can accept invitations.  Invitations can only be accepted once.
    /// </remarks>
    /// <param name="id">The unique identifier for the target invitation</param>
    pplx::task<std::shared_ptr<Invitation>> invitationsIdAcceptPost(utility::string_t id);
    /// <summary>
    /// Get details about an invitation
    /// </summary>
    /// <remarks>
    /// Get details about an invitation. Only users who sent the invitation are permitted to read the invitation.
    /// </remarks>
    /// <param name="id">The unique identifier for the target invitation</param>/// <param name="recursive">Return full details of embedded resources (optional, default to false)</param>
    pplx::task<std::shared_ptr<Invitation>> invitationsIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Send a new invitation
    /// </summary>
    /// <remarks>
    /// Send a new invitation.  Users must have the AssignRolePermission to be able to send invitations within their organisation and/or group.
    /// </remarks>
    /// <param name="body">Information about the invitation to be sent. (optional)</param>
    pplx::task<std::shared_ptr<Invitation>> invitationsPost(std::shared_ptr<InvitationPost> body);
    /// <summary>
    /// Get a count of locations.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Only return locations with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="description">Only return locations with this description or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="limit">Limit the number of results. The limit is 1000 by default (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="groupids">filter response by this group id (optional)</param>/// <param name="expand">Return full details of platforms (optional)</param>/// <param name="near">Return locations ordered based on how close they are to this WKT &#39;POINT&#39;. For example &#39;near&#x3D;POINT (lon lat)&#39; where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 for WTK Specification and examples. (optional)</param>/// <param name="radius">Limit results to locations within this distance (in metres) of the &#39;near&#39; location. (optional)</param>
    pplx::task<std::shared_ptr<LocationCollection>> locationsCountGet(utility::string_t id, utility::string_t description, double limit, double skip, utility::string_t organisationid, utility::string_t groupids, bool expand, utility::string_t near, double radius);
    /// <summary>
    /// Get a collection of locations.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Only return locations with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="description">Only return locations with this description or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="limit">Limit the number of results. The limit is 1000 by default (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="groupids">filter response by this group id (optional)</param>/// <param name="expand">Return full details of platforms (optional)</param>/// <param name="near">Return locations ordered based on how close they are to this WKT &#39;POINT&#39;. For example &#39;near&#x3D;POINT (lon lat)&#39; where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 for WTK Specification and examples. (optional)</param>/// <param name="radius">Limit results to locations within this distance (in metres) of the &#39;near&#39; location. (optional)</param>
    pplx::task<std::shared_ptr<LocationCollection>> locationsGet(utility::string_t id, utility::string_t description, double limit, double skip, utility::string_t organisationid, utility::string_t groupids, bool expand, utility::string_t near, double radius);
    /// <summary>
    /// Delete an existing location.
    /// </summary>
    /// <remarks>
    /// Delete an existing Location. The client must have an appropriate delete Location permission.
    /// </remarks>
    /// <param name="id"></param>/// <param name="cascade">Remove Location even when is referenced by other objects (eg. Platform deployments or Streams). (optional)</param>
    pplx::task<void> locationsIdDelete(utility::string_t id, bool cascade);
    /// <summary>
    /// Get details about a location.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Location id</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<void> locationsIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Create a new or update an existing Location
    /// </summary>
    /// <remarks>
    /// Create a new Location. If a Location with the posted &#39;id&#39; already exists then it will be overwritten.
    /// </remarks>
    /// <param name="id"></param>/// <param name="body">A &#x60;Location&#x60; describes a point with a known latitude and longitude (and, optionally, elevation above mean sea level).  The coordinates of the &#x60;Location&#x60; are specified using a [GeoJSON Point](http://geojson.org/geojson-spec.html#point) object, which by convention lists coordinates in the order longitude, latitude then elevation.  For example, the following snippet defines a &#x60;Location&#x60; located at 42.903 degrees South, 147.327 degrees East, and 25 metres above mean sea level:      {       \&quot;id\&quot;: \&quot;NewLocation\&quot;,       \&quot;organisationid\&quot;: \&quot;MyOrg\&quot;,       \&quot;geoJson\&quot;: {         \&quot;type\&quot;: \&quot;Point\&quot;,         \&quot;coordinates\&quot;: [147.327, -42.903, 25.0]       }     }  If elevation is unknown, pass only two values (the longitude and latitude) in the &#x60;coordinates&#x60; property.</param>
    pplx::task<void> locationsIdPut(utility::string_t id, std::shared_ptr<LocationPost> body);
    /// <summary>
    /// Delete observations from a stream
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="streamid"></param>
    pplx::task<void> observationsDelete(utility::string_t streamid);
    /// <summary>
    /// Get a collection of observations.
    /// </summary>
    /// <remarks>
    /// Get a collection of observations
    /// </remarks>
    /// <param name="streamid">Stream identifier or a comma separated list of stream identifiers</param>/// <param name="start">Start date (url encoded iso8601 format) (optional)</param>/// <param name="end">End date (url encoded iso8601 format) (optional)</param>/// <param name="time">Timestamp of a specific result. (url encoded iso8601 format) (optional)</param>/// <param name="si">Is the start parameter treated as an inclusive boundary (optional)</param>/// <param name="ei">Is the end parameter treated as an inclusive boundary (optional)</param>/// <param name="bounds">Boundary filter for a geolocation stream, or any stream located by a geolocation stream. The boundary is provided as a POLYGON in WTK format. (optional)</param>/// <param name="media">Format of response. Valid formats are csv, json, geojson (for geolocationvalue streams) (optional)</param>/// <param name="limit">Limit the number of results. The limit is 1000 by default. (optional)</param>/// <param name="sort">Sort the results. By default results are returned in ascending order. (optional)</param>
    pplx::task<void> observationsGet(utility::string_t streamid, utility::string_t start, utility::string_t end, utility::string_t time, bool si, bool ei, utility::string_t bounds, utility::string_t media, double limit, utility::string_t sort);
    /// <summary>
    /// Upload observations for a stream
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="streamid"></param>/// <param name="body"></param>
    pplx::task<void> observationsPost(utility::string_t streamid, std::shared_ptr<ObservationsPost> body);
    /// <summary>
    /// Get a collection of organisations.
    /// </summary>
    /// <remarks>
    /// This operations returns a list of all organisations.
    /// </remarks>
    
    pplx::task<std::shared_ptr<OrganisationCollection>> organisationsGet();
    /// <summary>
    /// Get details about an organisation.
    /// </summary>
    /// <remarks>
    /// Get details about a specific organisation
    /// </remarks>
    /// <param name="organisationid">Specify the orgnisation identifier</param>
    pplx::task<std::shared_ptr<Organisation>> organisationsOrganisationidGet(utility::string_t organisationid);
    /// <summary>
    /// Update or create a new organisation.
    /// </summary>
    /// <remarks>
    /// Add a new organisation. Only an administrator can create a new organisation. 
    /// </remarks>
    /// <param name="organisationid"></param>/// <param name="body">This must match the organisationid parameter in the path</param>
    pplx::task<std::shared_ptr<Organisation>> organisationsOrganisationidPut(utility::string_t organisationid, std::shared_ptr<OrganisationPost> body);
    /// <summary>
    /// Get a collection of platforms.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Only return platforms with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="name">Only return platforms with this name or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="limit">Maximum number of streams to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="expand">Return full details of platforms (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="groupids">filter response by a comma separated list of group ids (optional)</param>/// <param name="streamids">filter response by a comma separated list of stream ids (optional)</param>/// <param name="deployments_locationid">filter response to include only platforms deployed at this location. Note this will consider all deployment properties both past and present. (optional)</param>
    pplx::task<std::shared_ptr<PlatformCollection>> platformsGet(utility::string_t id, utility::string_t name, double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t streamids, utility::string_t deployments_locationid);
    /// <summary>
    /// Delete an existing platform.
    /// </summary>
    /// <remarks>
    /// Delete an existing Platform. The client must have an appropriate delete Platform permission.
    /// </remarks>
    /// <param name="id"></param>/// <param name="cascade">Remove Platform even when is referenced by other objects (eg. SensorDeployments). (optional)</param>
    pplx::task<void> platformsIdDelete(utility::string_t id, bool cascade);
    /// <summary>
    /// Get details about a platform.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Platform id</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<void> platformsIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Create a new or update an existing platform.
    /// </summary>
    /// <remarks>
    /// Create a new platform. If a platform with the posted &#39;id&#39; already exists then it will be overwritten.
    /// </remarks>
    /// <param name="id"></param>/// <param name="body"></param>
    pplx::task<void> platformsIdPut(utility::string_t id, std::shared_ptr<PlatformPost> body);
    /// <summary>
    /// Get a collection of sensing procedures.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="limit">Maximum number of sensing procedures to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="expand">Return full details of sensing procedures (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="groupids">filter response by a comma separated list of group ids (optional)</param>/// <param name="observedProperty">filter response by observedProperty (optional)</param>
    pplx::task<std::shared_ptr<SensingProcedureCollection>> proceduresGet(double limit, double skip, utility::string_t organisationid, bool expand, bool recursive, utility::string_t groupids, utility::string_t observedProperty);
    /// <summary>
    /// Delete an existing sensing procedure.
    /// </summary>
    /// <remarks>
    /// Delete an existing sensing procedure. The client must have an appropriate delete sensing procedure permission.
    /// </remarks>
    /// <param name="id"></param>/// <param name="cascade">Remove sensing procedure even when is referenced by other objects (eg. Streams). (optional)</param>
    pplx::task<void> proceduresIdDelete(utility::string_t id, bool cascade);
    /// <summary>
    /// Get details about a sensing procedures.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">sensing procedure id</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<void> proceduresIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Create a new or update an existing sensing procedure.
    /// </summary>
    /// <remarks>
    /// Create a new sensing procedure. If a sensing procedure with the posted &#39;id&#39; already exists then it will be overwritten.
    /// </remarks>
    /// <param name="id"></param>/// <param name="body"></param>
    pplx::task<void> proceduresIdPut(utility::string_t id, std::shared_ptr<SensingProcedurePost> body);
    /// <summary>
    /// Get a collection of roles.
    /// </summary>
    /// <remarks>
    /// This operation returns a list of all roles or all roles in the authorised organisation. An admin role with read role permission is required, or an organisational role with role read permission.
    /// </remarks>
    /// <param name="expand">Return full details of roles (optional)</param>/// <param name="recursive">Return full details of related objects (optional)</param>
    pplx::task<std::shared_ptr<RoleCollection>> rolesGet(bool expand, bool recursive);
    /// <summary>
    /// Delete an existing role.
    /// </summary>
    /// <remarks>
    /// Delete an existing role. The client must have a delete role permission.
    /// </remarks>
    /// <param name="roleid"></param>
    pplx::task<void> rolesRoleidDelete(utility::string_t roleid);
    /// <summary>
    /// Get details about a specific role.
    /// </summary>
    /// <remarks>
    /// Get role details
    /// </remarks>
    /// <param name="roleid">Specify the role identifier</param>/// <param name="recursive">Return full details of related objects (optional)</param>
    pplx::task<std::shared_ptr<Role>> rolesRoleidGet(utility::string_t roleid, bool recursive);
    /// <summary>
    /// Update or create a role.
    /// </summary>
    /// <remarks>
    /// Add or update a Role. The User will need to have admin level Roles for creating or updating a Role, or an organisation level Role for creating or updating a Role.  Permissions can be one or more of the following - .AllPermission, .AllReadPermission, .AssignRolePermission, .CreateCollectionPermission, .CreateGroupPermission, .CreateLocationPermission, .CreateOrganisationPermission, .CreatePlatformPermission, .CreateProcedurePermission, .CreateResultsPermission, .CreateRolePermission, .CreateSharePermission, .CreateStreamPermission, .CreateUserPermission, .DeleteCollectionPermission, .DeleteGroupPermission, .DeleteLocationPermission, .DeleteOrganisationPermission, .DeletePlatformPermission, .DeleteProcedurePermission, .DeleteResultsPermission, .DeleteRolePermission, .DeleteSharePermission, .DeleteStreamPermission, .DeleteUserPermission, .ReadCollectionPermission, .ReadGroupPermission, .ReadLocationPermission, .ReadModelPermission, .ReadOrganisationPermission, .ReadPlatformPermission, .ReadProcedurePermission, .ReadResultsPermission, .ReadRolePermission, .ReadSharePermission, .ReadStreamPermission, .ReadUserPermission, .ReadWorkflowPermission, .ReadWorkflowResultsPermission, .RunWorkflowPermission, .UpdateCollectionPermission, .UpdateGroupPermission, .UpdateLocationPermission, .UpdateOrganisationPermission, .UpdatePlatformPermission, .UpdateProcedurePermission, .UpdateResultsPermission, .UpdateRolePermission, .UpdateSharePermission, .UpdateStreamPermission, .UpdateUserPermission, .WriteModelPermission, .WriteWorkflowPermission.  A client can only assign a permission to a role of a certain role scope if they already have a role with the &#39;createrolepermission&#39;. For example if user a has an OrganisationRole with &#39;createrolepermission&#39; they will beable to create an organisation role with any permission. Importantly they can only create an organisation role for the organisation with which they already have a &#39;createrolepermission&#39;.   Similarly, if a client has a GroupRole with createrolepermission on &#39;group1&#39; then they can create an other GroupRole with any permission.  Given this, the &#39;createrolepermission&#39; essentially allows the client to do anything with the the scope of the role. 
    /// </remarks>
    /// <param name="roleid"></param>/// <param name="body">This must match the roleid parameter in the path</param>
    pplx::task<std::shared_ptr<Role>> rolesRoleidPut(utility::string_t roleid, std::shared_ptr<RolePost> body);
    /// <summary>
    /// Sensor Data API Root
    /// </summary>
    /// <remarks>
    /// The root resource of the sensor data API. Provides links to other resources and some general meta-data about the user and the API 
    /// </remarks>
    
    pplx::task<void> rootGet();
    /// <summary>
    /// Get a count of current shares.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="limit">Maximum number of shares to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="groupid">filter response by a comma separated list of group ids (optional)</param>/// <param name="collectionid">filter response by a comma separated list of collection ids (optional)</param>/// <param name="expand">Return full details of shares (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<std::shared_ptr<ShareCollection>> sharesCountGet(double limit, double skip, utility::string_t organisationid, utility::string_t groupid, utility::string_t collectionid, bool expand, bool recursive);
    /// <summary>
    /// Get a list of current shares.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="limit">Maximum number of shares to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="organisationid">filter response by this organisation id (optional)</param>/// <param name="groupid">filter response by a comma separated list of group ids (optional)</param>/// <param name="collectionid">filter response by a comma separated list of collection ids (optional)</param>/// <param name="expand">Return full details of shares (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<std::shared_ptr<ShareCollection>> sharesGet(double limit, double skip, utility::string_t organisationid, utility::string_t groupid, utility::string_t collectionid, bool expand, bool recursive);
    /// <summary>
    /// Delete an existing Share.
    /// </summary>
    /// <remarks>
    /// Delete an existing Share. The client must have an appropriate delete Share permission.
    /// </remarks>
    /// <param name="id"></param>
    pplx::task<void> sharesIdDelete(utility::string_t id);
    /// <summary>
    /// Get details about a share.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Share id</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<void> sharesIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Update an existing Share.
    /// </summary>
    /// <remarks>
    /// Update an existing Share. The existing object will be overwritten.
    /// </remarks>
    /// <param name="id"></param>/// <param name="body"></param>
    pplx::task<void> sharesIdPut(utility::string_t id, std::shared_ptr<SharePut> body);
    /// <summary>
    /// Create a new share.
    /// </summary>
    /// <remarks>
    /// Create a new share. Do not provide the id property in the body. The server will generate a UUID.
    /// </remarks>
    /// <param name="body"></param>
    pplx::task<void> sharesPost(std::shared_ptr<SharePost> body);
    /// <summary>
    /// Count a collection of streams.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Only return streams with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="limit">Maximum number of streams to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="resulttype">Return only Streams which match this resulttype. Valid resulttypes are geolocationvalue, scalarvalue, imagevalue and vectorvalue (optional)</param>/// <param name="expand">Return full details of streams (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="groupids">Only return streams in this group (optional)</param>/// <param name="organisationid">Only return streams in this organisation (optional)</param>/// <param name="locationid">Only return streams with this location (optional)</param>/// <param name="near">Return streams at locations based on how close they are to this WKT &#39;POINT&#39;. For example &#39;near&#x3D;POINT (lon lat)&#39; where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 for WTK Specification and examples. (optional)</param>/// <param name="radius">Limit results to streams that have locations within this distance (in metres) of the &#39;near&#39; location. (optional)</param>/// <param name="streamMetadata_observedProperty">Only return streams with this observed property URI (optional)</param>/// <param name="streamMetadata_unitOfMeasure">Only return streams with this unit of measure URI (optional)</param>/// <param name="properties">Provide a comma separated list of properties to include in the collection. (optional)</param>
    pplx::task<std::shared_ptr<StreamCollectionCount>> streamsCountGet(utility::string_t id, double limit, double skip, utility::string_t resulttype, bool expand, bool recursive, utility::string_t groupids, utility::string_t organisationid, utility::string_t locationid, utility::string_t near, double radius, utility::string_t streamMetadata_observedProperty, utility::string_t streamMetadata_unitOfMeasure, utility::string_t properties);
    /// <summary>
    /// Get a collection of streams.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id">Only return streams with this id or partial match using wildcards (*, ?).   * matches zero or more characters. * ? matches exactly one character.  For example, bo* will match any word starting with bo, such as bo, bom, body, and so on. On the other hand, bo? will only match three-letter words starting with bo, such as bo, bom, and so on. (optional)</param>/// <param name="limit">Maximum number of streams to return (optional)</param>/// <param name="skip">Skip this many results. (optional)</param>/// <param name="resulttype">Return only Streams which match this resulttype. Valid resulttypes are geolocationvalue, scalarvalue, imagevalue and vectorvalue (optional)</param>/// <param name="expand">Return full details of streams (optional)</param>/// <param name="recursive">Return full details of embedded resources (optional)</param>/// <param name="groupids">Only return streams in this group (optional)</param>/// <param name="organisationid">Only return streams in this organisation (optional)</param>/// <param name="locationid">Only return streams with this location (optional)</param>/// <param name="near">Return streams at locations based on how close they are to this WKT &#39;POINT&#39;. For example &#39;near&#x3D;POINT (lon lat)&#39; where lon and lat are your GPS coordinates. See http://portal.opengeospatial.org/files/?artifact_id&#x3D;25355 for WTK Specification and examples. (optional)</param>/// <param name="radius">Limit results to streams that have locations within this distance (in metres) of the &#39;near&#39; location. (optional)</param>/// <param name="streamMetadata_observedProperty">Only return streams with this observed property URI (optional)</param>/// <param name="streamMetadata_unitOfMeasure">Only return streams with this unit of measure URI (optional)</param>/// <param name="properties">Provide a comma separated list of properties to include in the collection. (optional)</param>
    pplx::task<std::shared_ptr<StreamCollection>> streamsGet(utility::string_t id, double limit, double skip, utility::string_t resulttype, bool expand, bool recursive, utility::string_t groupids, utility::string_t organisationid, utility::string_t locationid, utility::string_t near, double radius, utility::string_t streamMetadata_observedProperty, utility::string_t streamMetadata_unitOfMeasure, utility::string_t properties);
    /// <summary>
    /// Delete an existing stream.
    /// </summary>
    /// <remarks>
    /// Delete an existing stream. The client must have an appropriate delete stream permission.
    /// </remarks>
    /// <param name="id"></param>
    pplx::task<void> streamsIdDelete(utility::string_t id);
    /// <summary>
    /// Get details about a stream.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="id"></param>/// <param name="recursive">Return full details of embedded resources (optional)</param>
    pplx::task<std::shared_ptr<Stream>> streamsIdGet(utility::string_t id, bool recursive);
    /// <summary>
    /// Create a new or update an existing Stream.
    /// </summary>
    /// <remarks>
    /// Create a new Stream. If a stream with the posted &#39;id&#39; already exists then it will be overwritten.
    /// </remarks>
    /// <param name="id"></param>/// <param name="body"></param>
    pplx::task<void> streamsIdPut(utility::string_t id, std::shared_ptr<StreamPost> body);
    /// <summary>
    /// Get a collection of users.
    /// </summary>
    /// <remarks>
    /// This request will return a collection of all users known to the Sensor Data API. Only Organisation or Admin roles with the read user permission will be authorised.
    /// </remarks>
    /// <param name="expand">Return full details of users (optional)</param>/// <param name="recursive">Return full details of roles (optional)</param>/// <param name="roleids">A commona separated list of roleids to filter the returned roles. (optional)</param>
    pplx::task<std::shared_ptr<UserCollection>> usersGet(bool expand, bool recursive, utility::string_t roleids);
    /// <summary>
    /// Get details about a user.
    /// </summary>
    /// <remarks>
    /// Returns a User object for the specified user. You must either be authenticated as the requested user or have an administration or organisation role with read user permission. If a user id is not specified then details about the currently authenticated user will be returned.
    /// </remarks>
    /// <param name="userid">Specify a user id (email address)</param>/// <param name="recursive">Return full details of linked objects (optional)</param>
    pplx::task<std::shared_ptr<User>> usersUseridGet(utility::string_t userid, bool recursive);
    /// <summary>
    /// Update or create a user.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <param name="userid">Specify a user id (email address)</param>/// <param name="body">This must match the userid parameter in the path</param>
    pplx::task<std::shared_ptr<User>> usersUseridPut(utility::string_t userid, std::shared_ptr<UserPost> body);
    /// <summary>
    /// Search for vocabulary terms.
    /// </summary>
    /// <remarks>
    /// This operation will query linked registers. A query and type parameter must be provided. Using this operation a client can search for possible matches on both units of measure and observed property.
    /// </remarks>
    /// <param name="query">Keywords to search. &#39;*&#39; wild cards are permitted.</param>/// <param name="type">Uri of concept type. Typically will be http://qudt.org/schema/qudt#Unit for units of measure and http://qudt.org/schema/qudt#QuantityKind for observed properties. Don&#39;t forget to URL encode the parameters.</param>
    pplx::task<std::shared_ptr<VocabularyCollection>> vocabularyGet(utility::string_t query, utility::string_t type);
    /// <summary>
    /// Resolve a specific vocabulary term
    /// </summary>
    /// <remarks>
    /// This operation will resolve a URI and return a JSON-LD document. Vocabulary terms can be resolved directly, however this operation allows an application to avoid mixed http/https content problems by using https to resolve the term. Only URIs from the whitelisted linked data registry instances are permitted.
    /// </remarks>
    /// <param name="id">URI of vocabulary term to resolve.</param>
    pplx::task<void> vocabularyProxyGet(utility::string_t id);

protected:
    std::shared_ptr<ApiClient> m_ApiClient;
};

}
}
}
}

#endif /* DefaultApi_H_ */

